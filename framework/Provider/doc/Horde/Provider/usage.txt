Introduction
============

Dependency injection
(http://en.wikipedia.org/wiki/Dependency_injection) is a useful design
pattern that can help to avoid using global variables or state. If a
class depends on a connection to a database then this connection is
often pulled into the class using a singleton pattern or by using a
global variable.

Instead of providing the class with knowlegde about the global state
it is often preferable to "inject" the dependency into the class from
the outside. This usually happens within the class constructor. Thus
the dependencies of a class are immediately visible without searching
the code for references to the global scope. Another major benefit of
dependency injection is the fact that it facilitates unit testing of
complex systems.

Horde_Provider
==============

For PHP there exist several "Dependency Injection" frameworks
(e.g. http://stubbles.net,
http://components.symfony-project.org/dependency-injection) with
extensive feature lists. So there is hardly any need for another
framework with similar capabilities.

The essential part of dependency injection is the structure of classes
with dependencies. They need to be amenable for an external management
of their dependencies. If that is the case for a given class then most
frameworks should have no problem handling this class within the
framework. The choice of the actual framework should not matter
anymore.

In consequence Horde_Provider provides only a minimal version of
dependency injection that is mainly inspired by Twittee
(http://twittee.org/). The goal is to drive refactoring of classes
with complex dependencies so that they can be used with a dependency
injection framework.

Making classes amenable to dependency injection
===============================================

As trivial as it may sound: a class can be managed by a dependency
injection framework if the class allows the framework to inject its
dependencies from the outside. That means that the class may *NOT*

 - pull in an dependency using global state via the singleton
   pattern:

    External_Class::singleton())

 - create new objects with dependencies:

    $db = new DB();
    $b = new User($db);

 - use global variables:

    if ($conf['a']) echo 'yes';

In most cases the class should receive dependencies and required
parameters within the constructor.

Using Horde_Provider
====================

The Horde_Provider_Base class is a simple container that allows you to
fill it with a number of elements that can be retrieved later:

 $a = new Horde_Provider_Base();
 $a->a = 'a';
 echo $a->a;

 a

Classes with dependencies are represented by registering a wrapper
object that implements the Horde_Provider_Injection interface:

 function factory() { return 'constructed'; }
 $a = new Horde_Provider_Base();
 $b = new Horde_Provider_Injection_Factory('factory');
 $a->inject = $b;
 echo $a->inject;

 constructed

The example above demonstrates this approach by using the
Horde_Provider_Injection_Factory which implements
Horde_Provider_Injection. The class allows to register a callable
function. It will use this function to construct the required
object. Here the factory function is simple though and does not return
an object but a string.

Preparing a class for Horde_Provider
====================================

Assume you have the following simple class that represents a common
structure found in many of the Horde packages:

 class Horde_X
 {
     /**
      * Instance object.
      *
      * @var Horde_X
      */
     static protected $_instance;
 
     /**
      * Pointer to a DB instance.
      *
      * @var DB
      */
     protected $_db;
 
     /**
      * Attempts to return a reference to a concrete Horde_X instance.
      *
      * @return Horde_X  The concrete Horde_X reference.
      * @throws Horde_Exception
      */
     static public function singleton()
     {
         if (!isset(self::$_instance)) {
             self::$_instance = new Horde_X();
         }
 
         return self::$_instance;
     }
 
     /**
      * Constructor.
      */
     public function __construct()
     {
         global $conf;
 
         $this->_db = DB::connect($conf['sql']);
     }
 }

The class obviously depends on a database connection. The constructor
above does not allow for dependency injection as it constructs the
database connection itself. It uses the global variable $conf in order
to get the settings for this connection. A constructor allowing
dependency injection would look like this:

     /**
      * Constructor.
      *
      * @param DB $db A database connection.
      */
     public function __construct(DB $db)
     {
         $this->_db = $db;
     }

Of course this connection must be provided from somewhere. The
application using Horde_X might simply provide it when creating the
Horde_X instance. If the application is however using a dependency
injection framework then this framework would be required to provide
the required database connection.

If the application uses Horde_Provider it would be necessary to
provide a factory method as Horde_Provider currently only allows to
call factory methods via Horde_Provider_Injection_Factory:

     /**
      * Return a reference to a new Horde_X instance.
      *
      * @return Horde_X  The new Horde_X reference.
      */
     static public function factory($provider)
     {
         $x = new Horde_X($provider->db)
         return $x;
     }

The fact that we need this factory method is a specific shortcoming of
the current capabilites of the Horde_Provider system. A more complex
dependency injection framework would have the ability to look at the
Horde_X constructor. It would then fetch the required dependencies
based on the constructor arguments. Type hinting is usually required
to inform the framework of the required dependency. In case of Horde_X
we used type hinting to indicate that we need an object of type "DB"
as parameter "$db".

Getting rid of singletons?
==========================

From the viewpoint of dependency injection Horde_X can be used now as
it allows external injection of its dependencies. We could throw away
the singleton now. There might be some reasons however why we would
like to keep the singleton() method. One of the reasons might be
backward compatibility as some other classes or applications are bound
to use the method. Another reason might be that we want to clarify how
to get a functional instance of the class to somebody just looking at
the Horde_X class. The factory method requires that there is a
$provider object "magically" providing the db connection.

We could keep the following singleton method:

     static public function singleton()
     {
         if (!isset(self::$_instance)) {
             global $conf;
 
	     $provider = new stdClass;
	     $provider->db = DB::connect($conf['sql']);
             self::$_instance = Horde_X::factory($provider);
         }
 
         return self::$_instance;
     }

In this specific case it would probably be easier to directly use the
Horde_X constructor rather than the factory method but there might be
situations where the factory method has a higher complexity.

We do not gain much here: The magic $provider->db parameter is
exchanged against the magic $conf['sql'] parameter. However the
singleton demonstrates how the DB class is instantiated via the
DB::connect() method. That is something that was not visible in the
factory method.

A decent singleton method would require the database configuration as
a parameter for the method and refer to the DB class for details
concerning the possible configuration settings. That would however
break backward compatibility for the method.

Result
======

The final result that can be used with a dependency injection
framework and still provides a backward compatible singleton method:

 class Horde_X
 {
     /**
      * Instance object.
      *
      * @var Horde_X
      */
     static protected $_instance;
 
     /**
      * Pointer to a DB instance.
      *
      * @var DB
      */
     protected $_db;
 
     /**
      * Attempts to return a reference to a concrete Horde_X instance.
      *
      * @return Horde_X  The concrete Horde_X reference.
      */
     static public function singleton()
     {
         if (!isset(self::$_instance)) {
             global $conf;
 
	     $provider = new stdClass;
	     $provider->db = DB::connect($conf['sql']);
             self::$_instance = Horde_X::factory($provider);
         }
 
         return self::$_instance;
     }
 
     /**
      * Return a reference to a new Horde_X instance.
      *
      * @return Horde_X  The new Horde_X reference.
      */
     static public function factory($provider)
     {
         $x = new Horde_X($provider->db)
         return $x;
     }

     /**
      * Constructor.
      *
      * @param DB $db A database connection.
      */
     public function __construct(DB $db)
     {
         $this->_db = $db;
     }
 }
